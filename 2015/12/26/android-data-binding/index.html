<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MVVM 与 Android Data Binding | 雲之彼岸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在 Android 开发过程中，由于 Android 作为 View 描述的 xml 视图功能较弱，开发中很容易写出臃肿繁杂的 Activity/Fragment，甚至有写出过数千行代码的 Activity。大量的显示、校验、事件响应、回调接口充斥在 Activity 中。Activity/Fragment 实际上成了 View 和 Controller 的混合体，既要承担 View 的显示功能，">
<meta property="og:type" content="article">
<meta property="og:title" content="MVVM 与 Android Data Binding">
<meta property="og:url" content="http://fyun.li/2015/12/26/android-data-binding/index.html">
<meta property="og:site_name" content="雲之彼岸">
<meta property="og:description" content="在 Android 开发过程中，由于 Android 作为 View 描述的 xml 视图功能较弱，开发中很容易写出臃肿繁杂的 Activity/Fragment，甚至有写出过数千行代码的 Activity。大量的显示、校验、事件响应、回调接口充斥在 Activity 中。Activity/Fragment 实际上成了 View 和 Controller 的混合体，既要承担 View 的显示功能，">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/620f1e7egw1ezf5hz0emcj20ao04kt8t.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/620f1e7ejw1ezf6uoj1wwj20ao04kaa6.jpg">
<meta property="og:image" content="http://ww2.sinaimg.cn/large/620f1e7egw1ezf77ncrhuj20ao05tmx8.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/620f1e7ejw1ezf7lvm7nsj20ao05q3yo.jpg">
<meta property="og:image" content="http://ww3.sinaimg.cn/large/620f1e7ejw1ezf7yaf6gej20ao05t0su.jpg">
<meta property="og:updated_time" content="2015-12-28T07:46:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MVVM 与 Android Data Binding">
<meta name="twitter:description" content="在 Android 开发过程中，由于 Android 作为 View 描述的 xml 视图功能较弱，开发中很容易写出臃肿繁杂的 Activity/Fragment，甚至有写出过数千行代码的 Activity。大量的显示、校验、事件响应、回调接口充斥在 Activity 中。Activity/Fragment 实际上成了 View 和 Controller 的混合体，既要承担 View 的显示功能，">
  
    <link rel="alternative" href="/atom.xml" title="雲之彼岸" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://ww3.sinaimg.cn/large/620f1e7egw1ey8bjsbmr2j20b40b475e.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">fyunli</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/fyunli" title="github">github</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/fyunli" title="twitter">twitter</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/fyunli" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="http://fyun.li/rss2.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/cors/" style="font-size: 10px;">cors</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/jsonp/" style="font-size: 10px;">jsonp</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pentaho/" style="font-size: 20px;">pentaho</a> <a href="/tags/report/" style="font-size: 15px;">report</a> <a href="/tags/ssl/" style="font-size: 10px;">ssl</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/墙你妹/" style="font-size: 10px;">墙你妹</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">静若流光，空如此生</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">fyunli</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://ww3.sinaimg.cn/large/620f1e7egw1ey8bjsbmr2j20b40b475e.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">fyunli</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/fyunli" title="github">github</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/fyunli" title="twitter">twitter</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/fyunli" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="http://fyun.li/rss2.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-android-data-binding" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/26/android-data-binding/" class="article-date">
  	<time datetime="2015-12-26T12:02:00.000Z" itemprop="datePublished">2015-12-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MVVM 与 Android Data Binding
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/相对挨踢/">相对挨踢</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 Android 开发过程中，由于 Android 作为 View 描述的 xml 视图功能较弱，开发中很容易写出臃肿繁杂的 Activity/Fragment，甚至有写出过数千行代码的 Activity。大量的显示、校验、事件响应、回调接口充斥在 Activity 中。Activity/Fragment 实际上成了 View 和 Controller 的混合体，既要承担 View 的显示功能，又要承担 Controller 的控制功能。承担的功能过多，膨胀成繁芜的巨类也就不足为怪了。</p>
<h1 id="UI_界面设计模式">UI 界面设计模式</h1><p>在传统的 UI 设计模式中，MVC 已经实践中证明了其价值，并在漫长的使用过程中（（MVC最早出现于 1970 年代）演化出 MVP 和 MVVM 多个变种。</p>
<h2 id="MVC">MVC</h2><p>MVC 我们都知道是 Model-View-Controller，为了使得程序的各个部分分离降低耦合性，MVC 除了把应用程序分成 View、Model 层，还额外的加了一个 Controller 层，它的职责为进行 Model 和 View 之间的协作（路由、输入预处理等）的应用逻辑；Model 进行处理业务逻辑。</p>
<p><img src="http://ww4.sinaimg.cn/large/620f1e7egw1ezf5hz0emcj20ao04kt8t.jpg" alt="MVC Pattern"></p>
<p>MVC 通常的处理时序如下：</p>
<ol>
<li>View 接受用户的交互请求；</li>
<li>View 将请求转交给 Controller；</li>
<li>Controller 操作 Model 进行数据更新；</li>
<li>数据更新之后，Model 通知 View 数据变化；</li>
<li>View 显示更新之后的数据。</li>
</ol>
<p>通常 Model 使用 Observer 模式通知 View 数据变化：</p>
<p><img src="http://ww4.sinaimg.cn/large/620f1e7ejw1ezf6uoj1wwj20ao04kaa6.jpg" alt="MVC with Observer"></p>
<p>MVC 的优点：</p>
<ul>
<li>把业务逻辑和展示逻辑分离，模块化程度高。且当应用逻辑需要变更的时候，不需要变更业务逻辑和展示逻辑，只需要Controller换成另外一个Controller就行了（Swappable Controller）。</li>
<li>观察者模式可以做到多视图同时更新。</li>
</ul>
<p>MVD 的缺点：</p>
<ul>
<li>Controller 测试困难。因为视图同步操作是由 View 自己执行，而 View 只能在 UI 环境下运行。在没有 UI 环境下对 Controller 进行单元测试的时候，应用逻辑正确性是无法验证的：Model 更新的时候，无法对 View 的更新操作进行断言。</li>
<li>View 无法组件化。View 是强依赖特定的 Model 的，如果需要把这个 View 抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的 Model 是不一样的。</li>
<li>当有变化的时候需要同时维护 Model, View, Controller 及其交互，这显然让事情复杂化了。</li>
</ul>
<h2 id="MVP">MVP</h2><p>为了解决 MVC 的权限，MVP 对 MVC 进行了改良，MVP 模式把 MVC 模式中的 Controller 换成了 Presenter：</p>
<p><img src="http://ww2.sinaimg.cn/large/620f1e7egw1ezf77ncrhuj20ao05tmx8.jpg" alt="MVP Pattern"></p>
<p>MVP 通常的调用时序如下：</p>
<ol>
<li>View 接受用户的交互请求；</li>
<li>View 将请求转交给 Presenter；</li>
<li>Presenter 操作 Model 进行业务处理；</li>
<li>Model 通知 Presenter 数据发生变化；</li>
<li>Presenter 更新 View 的数据。</li>
</ol>
<p>和 MVC 不同的是，Presenter 会反作用于 View，不像 Controller 只能被动的接受 View 的指挥。</p>
<p>通常我们会抽象 View 接口，暴露属性和事件，然后 Presenter 引用 View 接口。这样可以很容易的构造 View 的 Mock 对象，提高可单元测试性。在这里，Presenter 的责任变大了，不仅要操作数据，而且要更新 View。</p>
<p>上面讲的是 MVP 的 Passive View 模式，该模式下 View 非常 Passive，它几乎什么都不知道，Presenter 让它干什么它就干什么。</p>
<p>在实际的实现中，有人会倾向于 奖 Presenter 一部分简单的同步逻辑交给 View 自己去做，Presenter 只负责比较复杂的、高层次的 UI 操作，所以可以把它看成一个 Supervising Controller，这种模式也被称为 The Supervising Controller MVP：</p>
<p><img src="http://ww4.sinaimg.cn/large/620f1e7ejw1ezf7lvm7nsj20ao05q3yo.jpg" alt="The Supervising Controller MVP"></p>
<p>MVP 的优点：</p>
<ul>
<li>便于测试。Presenter 对 View 是通过接口进行，在对 Presenter 进行不依赖 UI 环境的单元测试的时候。可以通过 Mock 一个 View 对象，这个对象只需要实现了 View 的接口即可。</li>
<li>View 可以进行组件化。在 MVP 当中，View 不依赖 Model。这样就可以让 View 从特定的业务场景中脱离出来，可以说 View 可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的 View组件。</li>
</ul>
<p>MVP 缺点：</p>
<ul>
<li>Presenter 中除了应用逻辑以外，还有大量的 View-&gt;Model，Model-&gt;View 的手动同步逻辑，造成 Presenter 比较笨重，维护起来会比较困难。</li>
</ul>
<h2 id="MVVM">MVVM</h2><p>MVVM 可以看作是一种特殊的 MVP（Passive View）模式，或者说是对 MVP 模式的进一步改良。</p>
<p>MVVM 模式最早是微软公司提出，并且了大量使用在.NET的WPF和Sliverlight中。2005年微软工程师John Gossman在自己的博客上首次公布了MVVM模式。</p>
<p><img src="http://ww3.sinaimg.cn/large/620f1e7ejw1ezf7yaf6gej20ao05t0su.jpg" alt="MVVM Pattern"></p>
<p>MVVM 代表的是 Model-View-ViewModel。MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致，唯一区别在于 ViewModel 将密切关联的 Model 和 View 的逻辑单独提取出来，用数据绑定将他们关联到一起。Model 的改变会通过 ViewModel 来映射到 View 上，反之亦然。数据绑定你可以认为是 Observer 模式或者是 Publish/Subscribe 模式，原理都是为了用一种统一的集中的方式实现频繁需要被实现的数据更新问题。</p>
<p>比起MVP，MVVM 不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。</p>
<p>MVVM 优点：</p>
<ul>
<li>省去了model变化之后手动修改view和view变化之后手动修改model的繁琐工作；</li>
<li>UI和功能更加松耦合了，功能的可测试性就越来越强。</li>
</ul>
<p>MVVM 缺点：</p>
<ul>
<li>在复杂的情况下，很难预先设计好足够通用的 ViewModel；</li>
<li>通常会依赖于特定的数据绑定框架；</li>
</ul>
<h1 id="Android_Data_Binding">Android Data Binding</h1><p>2015 Google IO 大会带来的 Data Binding 库使得 Android 开发者可以方便的实现 MVVM 架构模式。</p>
<blockquote>
<p>警告：Data Binding 库目前还是 Beta 版本，采用需谨慎。</p>
</blockquote>
<p>以下大部分内容摘录自<a href="http://segmentfault.com/a/1190000002876984" target="_blank" rel="external">Data Binding（数据绑定）用户指南</a>，根据 <a href="https://developer.android.com/intl/zh-cn/tools/data-binding/guide.html#data_binding_layout_files" target="_blank" rel="external">Android 官方英文指南</a> 做了一些更新。</p>
<h2 id="配置环境">配置环境</h2><p>最新版的 Android Studio 已经内置了对 Android Data Binding 框架的支持，配置起来也很简单，只需要在 app 的 build.gradle 文件中添加下面的内容就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android &#123;&#10;    ....&#10;    dataBinding &#123;&#10;        enabled = true&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Data_Binding_Layout_文件">Data Binding Layout 文件</h2><h3 id="Data_Binding_表达式">Data Binding 表达式</h3><p>Data Binding layout 文件有点不同的是：起始根标签是 layout，接下来一个 data 元素以及一个 view 的根元素。这个 view 元素就是你没有使用 Data Binding的layout文件的根元素。举例说明如下：</p>
<figure class="highlight xml"><figcaption><span>code snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">layout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">variable</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">type</span>=<span class="value">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">       <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">       <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">       <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">           <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">           <span class="attribute">android:text</span>=<span class="value">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">           <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">           <span class="attribute">android:text</span>=<span class="value">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在data内描述了一个名为user的变量属性，使其可以在这个layout中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;variable name=&#34;user&#34; type=&#34;com.example.User&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>在layout的属性表达式写作 @{}，下面是一个 TextView 的 text 设置为 user 的 firstName 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;TextView android:layout_width=&#34;wrap_content&#34;&#10;          android:layout_height=&#34;wrap_content&#34;&#10;          android:text=&#34;@&#123;user.firstName&#125;&#34;/&#62;</span><br></pre></td></tr></table></figure>
<h3 id="Data_Object">Data Object</h3><p>假设你有一个user的plain-old Java Object（POJO）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;&#10;   public final String firstName;&#10;   public final String lastName;&#10;   public User(String firstName, String lastName) &#123;&#10;       this.firstName = firstName;&#10;       this.lastName = lastName;&#10;   &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这个类型的对象拥有从不改变的数据。在 app 中它是常见的，可以读取一次并且之后从不改变。当然也可以使用 JavaBeans 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;&#10;   private final String firstName;&#10;   private final String lastName;&#10;   public User(String firstName, String lastName) &#123;&#10;       this.firstName = firstName;&#10;       this.lastName = lastName;&#10;   &#125;&#10;   public String getFirstName() &#123;&#10;       return this.firstName;&#10;   &#125;&#10;   public String getLastName() &#123;&#10;       return this.lastName;&#10;   &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>从 Data Binding 的角度来看，这两个类是等价的。用于 TextView 中的 android:text 属性的表达式 @{user.firstName} 将访问前者 POJO 对象中的 firstName 和后者 JavaBeans 对象中的 getFirstName() 方法。</p>
<h3 id="绑定数据">绑定数据</h3><p>默认情况下，一个 Binding 类会基于 layout 文件的名称而产生，将其转换为 Pascal case（译注：首字母大写的命名规范）并且添加 “Binding” 后缀。上述的 layout 文件是 activity_main.xml，因此生成的类名是 ActivityMainBinding。此类包含从 layout 属性到 layout 的 Views 中所有的 bindings（例如user变量），并且它还知道如何给 Binding 表达式分配数值。创建 bindings 的最简单的方式是在 inflating（译注：layout文件与Activity/Fragment的“链接”）期间如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override&#10;protected void onCreate(Bundle savedInstanceState) &#123;&#10;   super.onCreate(savedInstanceState);&#10;   ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity);&#10;   User user = new User(&#34;Test&#34;, &#34;User&#34;);&#10;   binding.setUser(user);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样，运行 app 后，你将会看到 Test User。或者你可以通过如下获取 View：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());</span><br></pre></td></tr></table></figure>
<p>如果你在 ListView 或者 RecyclerView adapter 使用 Data Binding 时，你可能会使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup,&#10;false);&#10;//or&#10;ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);</span><br></pre></td></tr></table></figure>
<h3 id="绑定事件">绑定事件</h3><p>就像你可以在xml文件里面使用属性android:onClick绑定Activity里面的一个方法一样，Data Binding Library 扩展了更多的事件可以用来绑定方法，比如 View.OnLongClickListener 有个方法 onLongClick(), 你就可以使用 android:onLongClick 属性来绑定一个方法，需要注意的是绑定的方法的签名必须和该属性原本对应的方法的签名完全一样，否则编译阶段会报错。</p>
<p>下面举例来说明具体怎么使用，先看用来绑定事件的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MyHandlers &#123;&#10;    public void onClickButton(View view) &#123; ... &#125;&#10;&#10;    public void afterFirstNameChanged(Editable s) &#123; ... &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是layout文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&#62;&#60;layout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&#62;&#10;    &#60;data&#62;&#10;        &#60;variable name=&#34;handlers&#34; type=&#34;com.example.Handlers&#34;/&#62;&#10;        &#60;variable name=&#34;user&#34; type=&#34;com.example.User&#34;/&#62;&#10;    &#60;/data&#62;&#10;    &#60;LinearLayout&#10;        android:orientation=&#34;vertical&#34;&#10;        android:layout_width=&#34;match_parent&#34;&#10;        android:layout_height=&#34;match_parent&#34;&#62;&#10;        &#60;EditText android:layout_width=&#34;wrap_content&#34;&#10;            android:layout_height=&#34;wrap_content&#34;&#10;            android:text=&#34;@&#123;user.firstName&#125;&#34;&#10;            android:afterTextChanged=&#34;@&#123;handlers.afterFirstNameChanged&#125;&#34;/&#62;&#10;        &#60;Button android:layout_width=&#34;wrap_content&#34;&#10;            android:layout_height=&#34;wrap_content&#34;&#10;            android:onClick=&#34;@&#123;handlers.onClickButton&#125;&#34;/&#62;&#10;    &#60;/LinearLayout&#62;&#60;/layout&#62;</span><br></pre></td></tr></table></figure>
<h2 id="深入_Layout_文件">深入 Layout 文件</h2><h3 id="Import">Import</h3><p>零个或多个 import 元素可能在 data 元素中使用。这些只用在你的 layout 文件中添加引用，就像在 Java 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;android.view.View&#34;/&#62;&#10;&#60;/data&#62;</span><br></pre></td></tr></table></figure>
<p>现在，View 可以使用你的 Binding 表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;TextView&#10;   android:text=&#34;@&#123;user.lastName&#125;&#34;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;&#10;   android:visibility=&#34;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>当类名有冲突时，其中一个类名可以重命名为alias:：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;import type=&#34;android.view.View&#34;/&#62;&#10;&#60;import type=&#34;com.example.real.estate.View&#34;&#10;        alias=&#34;Vista&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>这样，在该 layout 文件中 Vista 对应 com.example.real.estate.View，而View对应android.view.View。导入的类型可以在Variable和表达式中使用作为引用来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;com.example.User&#34;/&#62;&#10;    &#60;import type=&#34;java.util.List&#34;/&#62;&#10;    &#60;variable name=&#34;user&#34; type=&#34;User&#34;/&#62;&#10;    &#60;variable name=&#34;userList&#34; type=&#34;List&#60;User&#62;&#34;/&#62;&#10; &#60;/data&#62;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Android Studio还没有处理imports，所以自动导入Variable在你的IDE不能使用。您的app仍会正常编译，你可以在您的Variable定义中使用完全符合规定的名称来解决该IDE问题。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;TextView&#10;   android:text=&#34;@&#123;((User)(user.connection)).lastName&#125;&#34;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>导入的类型还可以在表达式中使用 static 属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;com.example.MyStringUtils&#34;/&#62;&#10;    &#60;variable name=&#34;user&#34; type=&#34;com.example.User&#34;/&#62;&#10;&#60;/data&#62;&#10;&#8230;&#10;&#60;TextView&#10;   android:text=&#34;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&#34;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;&#10;&#23601;&#20687;&#22312;Java&#20013;&#65292;java.lang&#12290;*&#26159;&#33258;&#21160;&#23548;&#20837;&#30340;&#12290;</span><br></pre></td></tr></table></figure>
<h3 id="Variables">Variables</h3><p>在data中可以使用任意数量的variable元素。每一个variable元素描述了一个用于layout文件中Binding表达式的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;android.graphics.drawable.Drawable&#34;/&#62;&#10;    &#60;variable name=&#34;user&#34;  type=&#34;com.example.User&#34;/&#62;&#10;    &#60;variable name=&#34;image&#34; type=&#34;Drawable&#34;/&#62;&#10;    &#60;variable name=&#34;note&#34;  type=&#34;String&#34;/&#62;&#10;&#60;/data&#62;</span><br></pre></td></tr></table></figure>
<p>该Variable类型在编译时检查，因此如果一个Variable实现了Observable或observable collection，这应该反映在类型中。（译注：需要查找资料来理解）如果variable是一个没有实现Observable接口的基本类或者接口，Variables不会被observed！</p>
<p>当对于多种配置有不同的layout文件时（如，横向或纵向），Variables会被合并。这些layout文件之间必须不能有冲突的Variable定义。</p>
<p>产生的Binding类对于每一个描述的Variables都会有setter和getter。这些Variables会使用默认的Java值 - null（引用类型）、0（int）、false（boolean）等等，直到调用setter时。</p>
<h3 id="自定义_Binding_类名称">自定义 Binding 类名称</h3><p>默认情况下，Binding类的命名是基于所述layout文件的名称，用大写开头，除去下划线（）以及（）后的第一个字母大写，然后添加“Binding”后缀。这个类将被放置在一个模块封装包里的databinding封装包下。例如，所述layout文件contact_item.xml将生成ContactItemBinding。如果模块包是com.example.my.app，那么它将被放置在com.example.my.app.databinding。</p>
<p>Binding类可通过调整data元素中的class属性来重命名或放置在不同的包中。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data class=&#34;ContactItem&#34;&#62;&#10;    ...&#10;&#60;/data&#62;</span><br></pre></td></tr></table></figure>
<p>在模块封装包的databinding包中会生成名为ContactItem的Binding类。如果要想让该类生成在不同的包种，你需要添加前缀.，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data class=&#34;.ContactItem&#34;&#62;&#10;    ...&#10;&#60;/data&#62;</span><br></pre></td></tr></table></figure>
<p>在这个情况下，ContactItem类直接在模块包种生成。或者你可以提供整个包名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data class=&#34;com.example.ContactItem&#34;&#62;&#10;    ...&#10;&#60;/data&#62;</span><br></pre></td></tr></table></figure>
<h3 id="Includes">Includes</h3><p>通过使用application namespace以及在属性中的Variable名字从容器layout中传递Variables到一个被包含的layout：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&#62;&#10;&#60;layout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&#10;        xmlns:bind=&#34;http://schemas.android.com/apk/res-auto&#34;&#62;&#10;   &#60;data&#62;&#10;       &#60;variable name=&#34;user&#34; type=&#34;com.example.User&#34;/&#62;&#10;   &#60;/data&#62;&#10;   &#60;LinearLayout&#10;       android:orientation=&#34;vertical&#34;&#10;       android:layout_width=&#34;match_parent&#34;&#10;       android:layout_height=&#34;match_parent&#34;&#62;&#10;       &#60;include layout=&#34;@layout/name&#34;&#10;           bind:user=&#34;@&#123;user&#125;&#34;/&#62;&#10;       &#60;include layout=&#34;@layout/contact&#34;&#10;           bind:user=&#34;@&#123;user&#125;&#34;/&#62;&#10;   &#60;/LinearLayout&#62;&#10;&#60;/layout&#62;</span><br></pre></td></tr></table></figure>
<p>注意：在name.xml以及contact.xml两个layout文件中必需要有user variable</p>
<p>Data binding 不支持包含 merge 元素作为直接的子元素，比如以下layout是不支持的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&#62;&#10;&#60;layout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&#10;        xmlns:bind=&#34;http://schemas.android.com/apk/res-auto&#34;&#62;&#10;   &#60;data&#62;&#10;       &#60;variable name=&#34;user&#34; type=&#34;com.example.User&#34;/&#62;&#10;   &#60;/data&#62;&#10;   &#60;merge&#62;&#10;       &#60;include layout=&#34;@layout/name&#34;&#10;           bind:user=&#34;@&#123;user&#125;&#34;/&#62;&#10;       &#60;include layout=&#34;@layout/contact&#34;&#10;           bind:user=&#34;@&#123;user&#125;&#34;/&#62;&#10;   &#60;/merge&#62;&#10;&#60;/layout&#62;</span><br></pre></td></tr></table></figure>
<h3 id="表达式语言">表达式语言</h3><p>常用表达式跟Java表达式很像，以下这些是一样的：</p>
<ul>
<li>数学表达式 + – / * %</li>
<li>字符串链接 +</li>
<li>逻辑操作符 &amp;&amp; ||</li>
<li>二元操作符 &amp; | ^</li>
<li>一元操作符 + – ! ~</li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>比较 == &gt; &lt; &gt;= &lt;=</li>
<li>instanceof</li>
<li>Grouping ()</li>
<li>Literals – character, String, numeric, null</li>
<li>Cast</li>
<li>函数调用</li>
<li>值域引用（Field access）</li>
<li>通过[]访问数组里面的对象</li>
<li>三元操作符 ?:</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#34;@&#123;String.valueOf(index + 1)&#125;&#34;&#10;android:visibility=&#34;@&#123;age &#60; 13 ? View.GONE : View.VISIBLE&#125;&#34;&#10;android:transitionName=&#39;@&#123;&#34;image_&#34; + id&#125;&#39;</span><br></pre></td></tr></table></figure>
<p>缺少的操作：</p>
<ul>
<li>this</li>
<li>super</li>
<li>new</li>
<li>显式泛型调用</li>
</ul>
<h4 id="Null合并操作">Null合并操作</h4><p>?? - 左边的对象如果它不是null，选择左边的对象；或者如果它是null，选择右边的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#34;@&#123;user.displayName ?? user.lastName&#125;&#34;</span><br></pre></td></tr></table></figure>
<p>函数上的写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#34;@&#123;user.displayName != null ? user.displayName : user.lastName&#125;&#34;</span><br></pre></td></tr></table></figure>
<h4 id="属性引用">属性引用</h4><p>我们已经在前边“Data Binding表达式”中提到了JavaBean引用的简短格式。</p>
<p>当一个表达式引用一个类的属性，它仍使用同样的格式对于字段、getters以及ObservableFields。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#34;@&#123;user.lastName&#125;&#34;</span><br></pre></td></tr></table></figure>
<h4 id="避免_NullPointerException">避免 NullPointerException</h4><p>Data Binding代码生成时自动检查是否为nulls来避免出现null pointer exceptions错误。例如，在表达式@{user.name}中，如果user是null，user.name会赋予它的默认值（null）。如果你引用user.age，age是int类型，那么它的默认值是0。</p>
<h4 id="集合">集合</h4><p>常用的集合：arrays、lists、sparse lists以及maps，为了简便都可以使用[]来访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;android.util.SparseArray&#34;/&#62;&#10;    &#60;import type=&#34;java.util.Map&#34;/&#62;&#10;    &#60;import type=&#34;java.util.List&#34;/&#62;&#10;    &#60;variable name=&#34;list&#34; type=&#34;List&#60;String&#62;&#34;/&#62;&#10;    &#60;variable name=&#34;sparse&#34; type=&#34;SparseArray&#60;String&#62;&#34;/&#62;&#10;    &#60;variable name=&#34;map&#34; type=&#34;Map&#60;String, String&#62;&#34;/&#62;&#10;    &#60;variable name=&#34;index&#34; type=&#34;int&#34;/&#62;&#10;    &#60;variable name=&#34;key&#34; type=&#34;String&#34;/&#62;&#10;&#60;/data&#62;&#10;&#8230;&#10;android:text=&#34;@&#123;list[index]&#125;&#34;&#10;&#8230;&#10;android:text=&#34;@&#123;sparse[index]&#125;&#34;&#10;&#8230;&#10;android:text=&#34;@&#123;map[key]&#125;&#34;</span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4><p>当使用单引号包含属性值时，在表达式中使用双引号很容易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#39;@&#123;map[&#34;firstName&#34;]&#125;&#39;</span><br></pre></td></tr></table></figure>
<p>使用双引号来包含属性值也是可以的。字符串前后需要使用”`”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#34;@&#123;map[`firstName`]&#125;&#34;&#10;android:text=&#34;@&#123;map[&#34;firstName&#34;]&#125;&#34;</span><br></pre></td></tr></table></figure>
<h4 id="Resources">Resources</h4><p>使用正常的表达式来访问resources也是可行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:padding=&#34;@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;&#34;</span><br></pre></td></tr></table></figure>
<p>格式化字符串和复数可以通过提供参数来判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#34;@&#123;@string/nameFormat(firstName, lastName)&#125;&#34;&#10;android:text=&#34;@&#123;@plurals/banana(bananaCount)&#125;&#34;</span><br></pre></td></tr></table></figure>
<p>当复数需要多个参数时，所有的参数都会通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  Have an orange&#10;  Have %d oranges&#10;&#10;android:text=&#34;@&#123;@plurals/orange(orangeCount, orangeCount)&#125;&#34;</span><br></pre></td></tr></table></figure>
<p>一些资源需要显式类型判断：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Normal Reference</th>
<th>Expression Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td>String[]</td>
<td>@array</td>
<td>@stringArray</td>
</tr>
<tr>
<td>int[]</td>
<td>@array</td>
<td>@intArray</td>
</tr>
<tr>
<td>TypedArray</td>
<td>@array</td>
<td>@typedArray</td>
</tr>
<tr>
<td>Animator</td>
<td>@animator</td>
<td>@animator</td>
</tr>
<tr>
<td>StateListAnimator</td>
<td>@animator</td>
<td>@stateListAnimator</td>
</tr>
<tr>
<td>color int</td>
<td>@color</td>
<td>@color</td>
</tr>
<tr>
<td>ColorStateList</td>
<td>@color</td>
<td>@colorStateList</td>
</tr>
</tbody>
</table>
<h2 id="Data_Object-1">Data Object</h2><p>任何Plain old Java object（PO​​JO）可用于Data Binding，但修改POJO不会导致UI更新。Data Binding的真正能力是当数据变化时，可以通知给你的Data对象。有三种不同的数据变化通知机制：Observable对象、ObservableFields以及observable collections。</p>
<p>当这些可观察Data对象​​绑定到UI，Data对象属性的更改后，UI也将自动更新。</p>
<h3 id="Observable_对象">Observable 对象</h3><p>实现android.databinding.Observable接口的类可以允许附加一个监听器到Bound对象以便监听对象上的所有属性的变化。</p>
<p>Observable接口有一个机制来添加和删除监听器，但通知与否由开发人员管理。为了使开发更容易，一个BaseObservable的基类为实现监听器注册机制而创建。Data实现类依然负责通知当属性改变时。这是通过指定一个Bindable注解给getter以及setter内通知来完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static class User extends BaseObservable &#123;&#10;   private String firstName;&#10;   private String lastName;&#10;   @Bindable&#10;   public String getFirstName() &#123;&#10;       return this.firstName;&#10;   &#125;&#10;   @Bindable&#10;   public String getFirstName() &#123;&#10;       return this.lastName;&#10;   &#125;&#10;   public void setFirstName(String firstName) &#123;&#10;       this.firstName = firstName;&#10;       notifyPropertyChanged(BR.firstName);&#10;   &#125;&#10;   public void setLastName(String lastName) &#123;&#10;       this.lastName = lastName;&#10;       notifyPropertyChanged(BR.lastName);&#10;   &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在编译期间，Bindable注解在BR类文件中生成一个Entry。BR类文件会在模块包内生成。如果用于Data类的基类不能改变，Observable接口通过方便的PropertyChangeRegistry来实现用于储存和有效地通知监听器。</p>
<h3 id="Observable_字段">Observable 字段</h3><p>一些小工作会涉及到创建Observable类，因此那些想要节省时间或者几乎没有几个属性的开发者可以使用ObservableFields。ObservableFields是自包含具有单个字段的observable对象。它有所有基本类型和一个是引用类型。要使用它需要在data对象中创建public final字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static class User extends BaseObservable &#123;&#10;   public final ObservableField&#60;String&#62; firstName =&#10;       new ObservableField&#60;&#62;();&#10;   public final ObservableField&#60;String&#62; lastName =&#10;       new ObservableField&#60;&#62;();&#10;   public final ObservableInt age = new ObservableInt();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样，要访问该值，使用set和get方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(&#34;Google&#34;);&#10;int age = user.age.get();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实践过程中，有时 notifyPropertyChanged(BR.lastName); 很容易引用错误，因此，开发过程中还是推荐使用 ObservableField。</p>
</blockquote>
<h3 id="Observable_集合">Observable 集合</h3><p>一些app使用更多的动态结构来保存数据。Observable集合允许键控访问这些data对象。ObservableArrayMap用于键是引用类型,如String。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&#60;String, Object&#62; user = new ObservableArrayMap&#60;&#62;();&#10;user.put(&#34;firstName&#34;, &#34;Google&#34;);&#10;user.put(&#34;lastName&#34;, &#34;Inc.&#34;);&#10;user.put(&#34;age&#34;, 17);</span><br></pre></td></tr></table></figure>
<p>在layout文件中，通过String键可以访问map：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;android.databinding.ObservableMap&#34;/&#62;&#10;    &#60;variable name=&#34;user&#34; type=&#34;ObservableMap&#60;String, Object&#62;&#34;/&#62;&#10;&#60;/data&#62;&#10;&#8230;&#10;&#60;TextView&#10;   android:text=&#39;@&#123;user[&#34;lastName&#34;]&#125;&#39;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;&#10;&#60;TextView&#10;   android:text=&#39;@&#123;String.valueOf(1 + (Integer)user[&#34;age&#34;])&#125;&#39;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>ObservableArrayList 在整形键值很有用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayList&#60;Object&#62; user = new ObservableArrayList&#60;&#62;();&#10;user.add(&#34;Google&#34;);&#10;user.add(&#34;Inc.&#34;);&#10;user.add(17);</span><br></pre></td></tr></table></figure>
<p>在layout文件中，通过索引可以访问list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;android.databinding.ObservableList&#34;/&#62;&#10;    &#60;import type=&#34;com.example.my.app.Fields&#34;/&#62;&#10;    &#60;variable name=&#34;user&#34; type=&#34;ObservableList&#60;Object&#62;&#34;/&#62;&#10;&#60;/data&#62;&#10;&#8230;&#10;&#60;TextView&#10;   android:text=&#39;@&#123;user[Fields.LAST_NAME]&#125;&#39;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;&#10;&#60;TextView&#10;   android:text=&#39;@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;&#39;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;</span><br></pre></td></tr></table></figure>
<h2 id="生成_Binding">生成 Binding</h2><p>Binding类的生成链接了layout中variables与Views。如前所述，Binding的名称和包名可以定制。所生成的Binding类都扩展了android.databinding.ViewDataBinding。</p>
<h3 id="创建">创建</h3><p>Binding应在inflation之后就立马创建，以确保View层次结构不在之前打扰layout中的binding到views上的表达式。有几个方法可以绑定到一个layout。最常见的是在Binding类上使用静态方法.inflate方法载入View的层次结构并且绑定到它只需这一步。还有一个更简单的版本，只需要LayoutInflater还有一个是采用ViewGroup：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater);&#10;MyLayoutBinding binding = MyLayoutBinding.inflate(LayoutInflater, viewGroup, false);</span><br></pre></td></tr></table></figure>
<p>如果使用不同的机制载入layout，他可一分开绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</span><br></pre></td></tr></table></figure>
<p>有时Binding不能提前知道，对于这种情况，可以使用DataBindingUtil类来创建Binding：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId,&#10;    parent, attachToParent);&#10;ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId);</span><br></pre></td></tr></table></figure>
<h3 id="带ID的Views">带ID的Views</h3><p>在layout中对于每个带ID的View会生成一个public final字段。Binding在View层次结构上做单一的传递，提取带ID的Views。这种机制比起某些Views使用findViewById还要快。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;layout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&#62;&#10;   &#60;data&#62;&#10;       &#60;variable name=&#34;user&#34; type=&#34;com.example.User&#34;/&#62;&#10;   &#60;/data&#62;&#10;   &#60;LinearLayout&#10;       android:orientation=&#34;vertical&#34;&#10;       android:layout_width=&#34;match_parent&#34;&#10;       android:layout_height=&#34;match_parent&#34;&#62;&#10;       &#60;TextView android:layout_width=&#34;wrap_content&#34;&#10;           android:layout_height=&#34;wrap_content&#34;&#10;           android:text=&#34;@&#123;user.firstName&#125;&#34;&#10;   android:id=&#34;@+id/firstName&#34;/&#62;&#10;       &#60;TextView android:layout_width=&#34;wrap_content&#34;&#10;           android:layout_height=&#34;wrap_content&#34;&#10;           android:text=&#34;@&#123;user.lastName&#125;&#34;&#10;  android:id=&#34;@+id/lastName&#34;/&#62;&#10;   &#60;/LinearLayout&#62;&#10;&#60;/layout&#62;</span><br></pre></td></tr></table></figure>
<p>它会生成如下的Binding类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final TextView firstName;&#10;public final TextView lastName;</span><br></pre></td></tr></table></figure>
<p>IDs不像没有Data Bindings那样几乎没有必要，但是仍然会有一些实例需要从代码中访问Views。</p>
<h3 id="Variables-1">Variables</h3><p>每个Variable会有访问方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;data&#62;&#10;    &#60;import type=&#34;android.graphics.drawable.Drawable&#34;/&#62;&#10;    &#60;variable name=&#34;user&#34;  type=&#34;com.example.User&#34;/&#62;&#10;    &#60;variable name=&#34;image&#34; type=&#34;Drawable&#34;/&#62;&#10;    &#60;variable name=&#34;note&#34;  type=&#34;String&#34;/&#62;&#10;&#60;/data&#62;</span><br></pre></td></tr></table></figure>
<p>它会在Binding中生成setters和getters：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract com.example.User getUser();&#10;public abstract void setUser(com.example.User user);&#10;public abstract Drawable getImage();&#10;public abstract void setImage(Drawable image);&#10;public abstract String getNote();&#10;public abstract void setNote(String note);</span><br></pre></td></tr></table></figure>
<h3 id="Binding进阶">Binding进阶</h3><h4 id="动态Variables">动态Variables</h4><p>有时，不知道具体的Binding类，例如，一个RecyclerView适配器对layouts任意操作并不知道具体的Binding类。它仍然必需在onBindViewHolder期间赋值给Binding。</p>
<p>在这个例子中，该RecyclerView绑定的所有layouts有一个“item”的Variable。该BindingHolder有一个getBinding方法返回ViewDataBinding。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void onBindViewHolder(BindingHolder holder, int position) &#123;&#10;   final T item = mItems.get(position);&#10;   holder.getBinding().setVariable(BR.item, item);&#10;   holder.getBinding().executePendingBindings();&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接Binding">直接Binding</h4><p>当一个variable或observable变化时，binding会在计划在下一帧之前执行改变。可能会发生很多次，但是在Binding时必须立即执行。要强制执行，使用executePendingBindings()方法。</p>
<h4 id="后台线程">后台线程</h4><p>只要它不是一个集合，你可以在后台线程中改变你的数据模型。在判断是否要避免任何并发问题时，Data Binding会对每个Varialbe/field本地化。</p>
<h2 id="属性Setters">属性Setters</h2><p>每当绑定值的变化，生成的Binding类必须调用setter方法。Data Binding 框架有可以自定义赋值的方法。</p>
<h3 id="自动Setters">自动Setters</h3><p>对于一个属性，Data Binding试图找到setAttribute方法。与该属性的namespace并不什么关系，仅仅与属性本身名称有关。</p>
<p>例如，有关TextView的android:text属性的表达式会寻找一个setText(String)的方法。如果表达式返回一个int，Data Binding会搜索的setText(int)方法。注意：要表达式返回正确的类型，如果需要的话使用casting。Data Binding仍会工作即使没有给定名称的属性存在。然后，您可以通过Data Binding轻松地为任何setter“创造”属性。例如，DrawerLayout没有任何属性，但有大量的setters。您可以使用自动setters来使用其中的一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;android.support.v4.widget.DrawerLayout&#10;    android:layout_width=&#34;wrap_content&#34;&#10;    android:layout_height=&#34;wrap_content&#34;&#10;    app:scrimColor=&#34;@&#123;@color/scrim&#125;&#34;&#10;    app:drawerListener=&#34;@&#123;fragment.drawerListener&#125;&#34;/&#62;</span><br></pre></td></tr></table></figure>
<h3 id="重命名的Setters">重命名的Setters</h3><p>一些有setters的属性按名称并不匹配。对于这些方法，属性可以通过BindingMethods注解相关联。这必须与一个包含BindingMethod注解的类相关联，每一个用于一个重命名的方法。例如，android:tint属性与setImageTintList相关联，而不与setTint相关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BindingMethods(&#123;&#10;       @BindingMethod(type = &#34;android.widget.ImageView&#34;,&#10;                      attribute = &#34;android:tint&#34;,&#10;                      method = &#34;setImageTintList&#34;),&#10;&#125;)</span><br></pre></td></tr></table></figure>
<p>以上例子，开发者需要重命名setters是不太可能了，android架构属性已经实现了。</p>
<h3 id="自定义Setters">自定义Setters</h3><p>有些属性需要自定义绑定逻辑。例如，对于android:paddingLeft属性并没有相关setter。相反，setPadding(left, top, right, bottom)是存在在。一个带有BindingAdapter注解的静态绑定适配器方法允许开发者自定义setter如何对于一个属性的调用。</p>
<p>Android的属性已经创造了BindingAdapters。举例来说，对于paddingLeft：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#34;android:paddingLeft&#34;)&#10;public static void setPaddingLeft(View view, int padding) &#123;&#10;   view.setPadding(padding,&#10;                   view.getPaddingTop(),&#10;                   view.getPaddingRight(),&#10;                   view.getPaddingBottom());&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Binding适配器对其他定制类型非常有用。例如，自定义loader可以用来异步载入图像。</p>
<p>当有冲突时，开发人员创建的Binding适配器将覆盖Data Binding默认适配器。</p>
<p>您也可以创建可以接收多个参数的适配器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#123;&#34;bind:imageUrl&#34;, &#34;bind:error&#34;&#125;)&#10;public static void loadImage(ImageView view, String url, Drawable error) &#123;&#10;   Picasso.with(view.getContext()).load(url).error(error).into(view);&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;ImageView app:imageUrl=&#8220;@&#123;venue.imageUrl&#125;&#8221;&#10;app:error=&#8220;@&#123;@drawable/venueError&#125;&#8221;/&#62;</span><br></pre></td></tr></table></figure>
<p>如果对于一个ImageViewimageUrl和error都被使用并且imageUrl是一个string类型以及error是一个drawable时，该适配器会被调用。</p>
<ul>
<li>匹配的过程中自定义namespaces将被忽略。</li>
<li>你也可以为Android namespaces写适配器。</li>
</ul>
<p>Binding适配器方法可能从handlers中获取旧的属性值. 同时获取新旧属性值的方法应该把旧的属性值作为参数放在前边，紧跟着是新的属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#34;android:paddingLeft&#34;)&#10;public static void setPaddingLeft(View view, int oldPadding, int newPadding) &#123;&#10;   if (oldPadding != newPadding) &#123;&#10;       view.setPadding(newPadding,&#10;                       view.getPaddingTop(),&#10;                       view.getPaddingRight(),&#10;                       view.getPaddingBottom());&#10;   &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>事件处理器可仅在接口或者抽象类中使用，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#34;android:onLayoutChange&#34;)&#10;public static void setOnLayoutChangeListener(View view, View.OnLayoutChangeListener oldValue,&#10;       View.OnLayoutChangeListener newValue) &#123;&#10;    if (Build.VERSION.SDK_INT &#62;= Build.VERSION_CODES.HONEYCOMB) &#123;&#10;        if (oldValue != null) &#123;&#10;            view.removeOnLayoutChangeListener(oldValue);&#10;        &#125;&#10;        if (newValue != null) &#123;&#10;            view.addOnLayoutChangeListener(newValue);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当监听器有多个方法时，必须被拆分成多个监听器。如 View.OnAttachStateChangeListener 有两个方法：onViewAttachedToWindow() 和 onViewDetachedFromWindow(). 则我们必须创建两个接口以为之区分属性和处理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)&#10;public interface OnViewDetachedFromWindow &#123;&#10;    void onViewDetachedFromWindow(View v);&#10;&#125;&#10;&#10;@TargetApi(VERSION_CODES.HONEYCOMB_MR1)&#10;public interface OnViewAttachedToWindow &#123;&#10;    void onViewAttachedToWindow(View v);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>因为改变某个监听器会影响到其他的监听器，我们必须编码三个不同的binding适配器，为每个属性各编写一个，并同时为两者一起编写一个，他们必须同时被设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#34;android:onViewAttachedToWindow&#34;)&#10;public static void setListener(View view, OnViewAttachedToWindow attached) &#123;&#10;    setListener(view, null, attached);&#10;&#125;&#10;&#10;@BindingAdapter(&#34;android:onViewDetachedFromWindow&#34;)&#10;public static void setListener(View view, OnViewDetachedFromWindow detached) &#123;&#10;    setListener(view, detached, null);&#10;&#125;&#10;&#10;@BindingAdapter(&#123;&#34;android:onViewDetachedFromWindow&#34;, &#34;android:onViewAttachedToWindow&#34;&#125;)&#10;public static void setListener(View view, final OnViewDetachedFromWindow detach,&#10;        final OnViewAttachedToWindow attach) &#123;&#10;    if (VERSION.SDK_INT &#62;= VERSION_CODES.HONEYCOMB_MR1) &#123;&#10;        final OnAttachStateChangeListener newListener;&#10;        if (detach == null &#38;&#38; attach == null) &#123;&#10;            newListener = null;&#10;        &#125; else &#123;&#10;            newListener = new OnAttachStateChangeListener() &#123;&#10;                @Override&#10;                public void onViewAttachedToWindow(View v) &#123;&#10;                    if (attach != null) &#123;&#10;                        attach.onViewAttachedToWindow(v);&#10;                    &#125;&#10;                &#125;&#10;&#10;                @Override&#10;                public void onViewDetachedFromWindow(View v) &#123;&#10;                    if (detach != null) &#123;&#10;                        detach.onViewDetachedFromWindow(v);&#10;                    &#125;&#10;                &#125;&#10;            &#125;;&#10;        &#125;&#10;        final OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view,&#10;                newListener, R.id.onAttachStateChangeListener);&#10;        if (oldListener != null) &#123;&#10;            view.removeOnAttachStateChangeListener(oldListener);&#10;        &#125;&#10;        if (newListener != null) &#123;&#10;            view.addOnAttachStateChangeListener(newListener);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子较通常而言稍微复杂一些，因为 View 通过 add/remove 来使用监听器，而不是为 View.OnAttachStateChangeListener 使用一个 set 方法。android.databinding.adapters.ListenerUtil 类保持对之前所有监听器的追踪，所以，他们必须从绑定适配器中移除。</p>
<p>通过对接口 OnViewDetachedFromWindow 和 OnViewAttachedToWindow 用 @TargetApi(VERSION_CODES.HONEYCOMB_MR1) 进行注解, 数据绑定代码生成器明白监听器仅需在运行 Honeycomb 及以上版本的设备上生成，<br>addOnAttachStateChangeListener(View.OnAttachStateChangeListener) 支持同样的版本.</p>
<h2 id="转换">转换</h2><h3 id="对象转换">对象转换</h3><p>当从Binding表达式返回一个对象，一个setter会从自动、重命名以及自定义的setters中选择。该对象将被转换为所选择的setter的参数类型。</p>
<p>这是为了方便那些使用ObservableMaps来保存数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;TextView&#10;   android:text=&#39;@&#123;userMap[&#34;lastName&#34;]&#125;&#39;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;</span><br></pre></td></tr></table></figure>
<p>在userMap返回一个对象并且该对象将自动转换为setText(CharSequence)的参数类型。当有关参数类型可能混乱时，开发人员需要在表达式中转换。</p>
<h3 id="自定义转换">自定义转换</h3><p>有时候转换应该是自动的在特定类型之间。例如，设置背景的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;View&#10;   android:background=&#34;@&#123;isError ? @color/red : @color/white&#125;&#34;&#10;   android:layout_width=&#34;wrap_content&#34;&#10;   android:layout_height=&#34;wrap_content&#34;/&#62;&#10;```   &#10;&#10;&#36825;&#37324;&#65292;&#32972;&#26223;&#38656;&#35201;Drawable&#23545;&#35937;&#65292;&#20294;&#39068;&#33394;&#26159;&#19968;&#20010;&#25972;&#25968;&#12290;&#19981;&#31649;&#20309;&#26102;&#26377;Drawable&#24182;&#19988;&#36820;&#22238;&#20540;&#26159;&#19968;&#20010;&#25972;&#25968;&#65292;&#37027;&#20040;&#25972;&#25968;&#31867;&#22411;&#20250;&#34987;&#36716;&#25442;&#20026;ColorDrawable&#12290;&#36825;&#20010;&#36716;&#25442;&#26159;&#36890;&#36807;&#20351;&#29992;&#24102;&#26377;BindingConversion&#27880;&#35299;&#30340;&#38745;&#24577;&#26041;&#27861;&#23436;&#25104;&#30340;&#65306;</span><br></pre></td></tr></table></figure>
<p>@BindingConversion<br>public static ColorDrawable convertColorToDrawable(int color) {<br>   return new ColorDrawable(color);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#27880;&#24847;&#65306;&#36716;&#25442;&#20165;&#20165;&#21457;&#29983;&#22312;setter&#32423;&#21035;&#65292;&#22240;&#27492;&#23427;&#19981;&#20801;&#35768;&#20197;&#19979;&#28151;&#21512;&#31867;&#22411;&#65306;</span><br></pre></td></tr></table></figure></p>
<p><view android:background="@{isError ? @drawable/error : @color/white}" android:layout_width="wrap_content" android:layout_height="wrap_content"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;## Android Studio &#23545;&#25968;&#25454;&#32465;&#23450;&#30340;&#25903;&#25345;&#10;&#10;Android Studio &#25903;&#25345;&#25968;&#25454;&#32465;&#23450;&#34920;&#36798;&#24335;&#30340;&#35821;&#27861;&#39640;&#20142;&#65292;&#24182;&#21487;&#22312;&#32534;&#36753;&#22120;&#20013;&#26631;&#31034;&#34920;&#36798;&#24335;&#35821;&#27861;&#38169;&#35823;&#12290;&#10;&#10;&#39044;&#35272;&#31383;&#26684;&#21487;&#26174;&#31034;&#25968;&#25454;&#32465;&#23450;&#34920;&#36798;&#24335;&#30340;&#39044;&#35774;&#40664;&#35748;&#20540;&#65292;&#22312;&#19979;&#38754;&#30340;&#20363;&#23376;&#20013;&#65292;&#39044;&#35272;&#31383;&#26684;&#22312; TextView &#20013;&#26174;&#31034;&#40664;&#35748;&#30340; PLACEHOLDER &#25991;&#26412;&#20540;&#12290;</span><br></pre></td></tr></table></figure></view></p>
<p><textview android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@{user.firstName, default=PLACEHOLDER}"><br>```</textview></p>
<p>如果你需要在设计期间显示默认值，你也可以使用 tools:attributes 代替默认表达式值。</p>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="https://github.com/livoras/blog/issues/11" target="_blank" rel="external">界面之下：还原真实的MV*模式</a></li>
<li><a href="https://developer.android.com/intl/zh-cn/tools/data-binding/guide.html#data_binding_layout_files" target="_blank" rel="external">Android 官方英文指南</a></li>
<li><a href="http://segmentfault.com/a/1190000002876984" target="_blank" rel="external">Data Binding（数据绑定）用户指南</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/12/19/ubuntu-ss/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Ubuntu 搭建 shadowsocks</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>





<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'fyunli'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 fyunli
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>